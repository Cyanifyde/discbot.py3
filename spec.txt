DISCORD BOT SPEC (FINAL) — Python 3.13, Minimal Resources, Exact Hash Matches

OWNER OVERRIDE (hard-coded)
- OWNER_ID = 701780009777496094
- This ID must NOT appear in any config files and must NOT be shown by any config/info command.
- Owner authorization works anywhere the bot can see (guilds + DMs).

SCOPE
- Moderation logic runs ONLY in config.guild_id (guild-dependent behavior).
- Ignore DMs for moderation logic.
- Treat thread messages the same as channel messages (thread has its own channel_id; no parent inheritance).

AUTHORIZATION (ALL COMMANDS)
- Every command is restricted to:
  - Owner (user.id == OWNER_ID), OR
  - Guild Administrator permission
- In DMs: only owner is authorized.
- /restart: owner ONLY.

NO MESSAGE LOGGING
- Do not log messages. Do not store message history.
- The ONLY persistent storage is under:
  ./.suspicion/<guild_id>/
  - lock.json
  - state.json
  - 00.json … 99.json (shards)
  - queue.jsonl
  - queue.state.json

CHANNEL LISTS
- ignored_channel_ids: bot ignores completely (no scanning, no suspicion updates).
- excluded_channel_ids: bot also ignores completely; pretend these channels do not exist (no scanning, no suspicion updates).
- normal channels: scanning + suspicion updates apply.
- Messages in ignored/excluded channels must not update last_message_at, must not increment counters, and must not clear suspicion.

HASH SOURCES (guild-dependent)
- The bot loads hashes from multiple sources and unions them into one in-memory set:
  - hashes_files: list of file paths (default includes ./hashes.txt)
  - extra_hashes: list of sha256 hex strings (optional; per-guild)
- Hash reload updates the in-memory set from the current effective config.

IMAGE INPUTS (guild-dependent; all enforced via queue)
The bot can detect images via up to three sources (enabled per guild config):
1) Attachments (default enabled)
2) Direct Discord CDN image URLs in message content (optional)
3) Discord message links (jump links) in message content that point to the SAME guild (optional)

All sources are processed via the same queue/worker system and the same hashing rules:
- At most 1 image source per message is enqueued/processed (attachment OR one eligible URL OR one eligible message link).
- If multiple are present, priority order:
  (A) attachment, else (B) direct CDN image URL, else (C) message link

IMAGE MATCHING (exact hash)
- Hash: SHA-256 of raw bytes (no decoding, no disk writes).
- Safety checks before hashing:
  - hard cap size (max_image_bytes)
  - read with timeout
  - validate magic bytes:
    PNG: 89 50 4E 47 0D 0A 1A 0A
    JPEG: FF D8 FF
    GIF: "GIF87a" or "GIF89a"
    WEBP: "RIFF"...."WEBP"
  - if magic bytes mismatch, skip
- If computed hash is in the loaded hash set => MATCH.

HASH MATCH ACTION (unless exempt)
- Delete the message that contained the attachment/URL/link.
- Remove all removable roles from the author:
  - never remove @everyone
  - skip managed roles
  - skip roles >= bot’s top role
- Add Unverified role if configured/exists.
- Post short action summary to action_log_channel_id (if set):
  - IDs only (no mentions)
  - include: user_id, channel_id, message_id, matched_hash, “image uploaded”, roles_removed_count, unverified_added yes/no
  - AllowedMentions.none()

EXEMPTIONS (applies to hash match + inactivity enforcement)
User is exempt if ANY are true:
- Has permissions: Administrator OR Manage Guild OR Manage Roles OR Manage Messages
- Has any role in exempt_role_ids
- user_id in exemptions

SUSPICION STORE (ONLY STORAGE)
Root: ./.suspicion/<guild_id>/
Shards: 00.json … 99.json where shard = first two digits of user_id string (pad to 2 digits if needed)

Shard structure: one JSON object keyed by user_id string
{
  "<user_id>": {
    "joined_at": "<ISO8601Z or null>",
    "last_message_at": "<ISO8601Z or null>",
    "nonexcluded_messages": <int>,
    "cleared": <bool>,
    "enforced": <bool>,
    "grace_until": "<ISO8601Z or null>"
  },
  ...
}

Record update rules (normal channels only)
- On a message in a normal channel:
  - last_message_at = now
  - nonexcluded_messages += 1
  - if nonexcluded_messages >= 1 => cleared = true
- Messages in ignored/excluded channels do nothing.

FIRST RUN + LOCK
- lock.json created on first run:
  { "guild_id": "<id>", "initialized_at": "<ISO8601Z>", "snapshot_complete": false }
- Baseline time for missing joined_at is lock.initialized_at.

SNAPSHOT ALL CURRENT MEMBERS ONCE (chunked across runs)
- Must snapshot all current guild members once, without loading all into memory.
- Use member pagination (fetch_members with limit/after).
- Store snapshot progress in state.json: snapshot_after, snapshot_complete.
- Each snapshot step processes up to snapshot_members_per_run members:
  - Create record if missing.
  - Store joined_at once: member.joined_at if available else null.
  - Apply grace for “existing at first run”:
    - If joined_at is null OR joined_at <= lock.initialized_at:
        grace_until = lock.initialized_at + first_run_grace_days
      else:
        grace_until = null
- When pagination ends, set lock.snapshot_complete = true.

INACTIVITY POLICY (only via daily/step enforcement)
- Only nonexcluded_messages count toward the talk threshold.
- Users with nonexcluded_messages > 3 must NEVER be unverified by inactivity policy (only by image hash match).
- Enforcement eligibility requires ALL:
  - not exempt
  - enforced == false
  - cleared == false
  - nonexcluded_messages <= 3
  - now >= grace_until if grace_until not null
  - inactivity timing:
    baseline = joined_at if present else lock.initialized_at
    if last_message_at is null: now - baseline >= inactive_days_threshold
    else: now - last_message_at >= inactive_days_threshold
- Enforcement action:
  - remove all removable roles (same rules as above)
  - add Unverified if configured/exists
  - set enforced = true
  - post short action summary (IDs only; AllowedMentions.none())

QUEUE-BASED PROCESSING (to avoid lockups)
- Do not perform network reads/hashing inline in on_message.
- Enqueue a scan job for eligible messages in normal channels.
- Bounded queue (queue_max_jobs); if full, drop enqueue and increment a counter in state.json.

Persistent queue files (per guild)
- queue.jsonl: append-only JSON Lines (jobs)
- queue.state.json: read offset + compaction metadata
- Jobs are read/written in chunks; never load entire queue.

Job JSONL line (source field distinguishes attachment vs URL vs message link)
{
  "v": 2,
  "enqueued_at": "ISO8601Z",
  "guild_id": "<int as string>",
  "channel_id": "<int as string>",
  "message_id": "<int as string>",
  "author_id": "<int as string>",
  "source": "attachment" | "discord_cdn_url" | "discord_message_link",
  "attachment": {
    "url": "<string>",
    "filename": "<string>",
    "size": <int>,
    "content_type": "<string|null>"
  },
  "url": "<string|null>",
  "linked": {
    "guild_id": "<string|null>",
    "channel_id": "<string|null>",
    "message_id": "<string|null>"
  }
}

Worker processing (discard on missing message)
- Run worker_count async workers.
- For each job:
  1) Fetch the original message by channel_id/message_id.
     - If NotFound or inaccessible: discard job.
  2) Re-check channel lists; if now ignored/excluded: discard.
  3) Re-check author exemption; if exempt: discard.
  4) Resolve bytes to hash (authoritative-first):
     A) If source == attachment:
        - read attachment from the fetched message’s attachment object (authoritative)
        - use stored attachment.url only as fallback if needed
     B) If source == discord_cdn_url:
        - download ONLY if url host is in allowed_discord_cdn_domains
        - enforce https scheme, size cap, timeout, magic bytes check
     C) If source == discord_message_link:
        - require linked.guild_id == config.guild_id
        - fetch the linked message from the linked channel
        - hash the first eligible image attachment from that linked message
  5) If hash matches: enforce actions against the author of the ORIGINAL message (the one who posted attachment/URL/link).
  6) Advance read_offset_bytes in queue.state.json periodically.

Queue compaction
- If read_offset_bytes exceeds queue_compact_threshold_bytes:
  - rewrite remaining/unprocessed portion to a new file and replace atomically
  - reset read_offset_bytes to 0

DISCORD CDN URL SCANNING (guild-dependent)
- Enabled only if enable_discord_cdn_url_scan == true.
- Extract URLs from message content with a strict regex.
- Only accept URLs whose host is in allowed_discord_cdn_domains (default: ["cdn.discordapp.com", "media.discordapp.net"]).
- Only accept https URLs.
- Do not follow redirects to non-allowed domains.
- Download with timeout and max_image_bytes cap; validate magic bytes before hashing.

DISCORD MESSAGE LINK SCANNING (guild-dependent)
- Enabled only if enable_discord_message_link_scan == true.
- Parse message jump links:
  https://discord.com/channels/<guild_id>/<channel_id>/<message_id>
  https://discordapp.com/channels/<guild_id>/<channel_id>/<message_id>
- Only accept if <guild_id> equals config.guild_id.
- Fetch that linked message; hash its first eligible image attachment.

DISK I/O SAFETY
- Atomic writes for lock.json, state.json, queue.state.json, and shard files (write temp then os.replace).
- Per-shard asyncio.Lock for shard read/modify/write.
- Maintain small shard LRU cache (2–5 shards).
- Flush dirty shards periodically and on shutdown.
- All file I/O via asyncio.to_thread.

OUTPUT SANITISATION
- All bot messages:
  - AllowedMentions.none()
  - no mentions (no <@...>, no @everyone/@here)
  - cap lengths; strip control characters; escape “@” as “@\u200b” if any user input is echoed
- Command input validation:
  - strict typing for config edits
  - IDs must be integers within sane range
  - lists must be lists of ints/strings as specified
  - time must match HH:MM 24h format
  - no user-controlled file paths

COMMANDS (all admin-only or owner; /restart owner-only)
- /help [topic]
- /health
- /server info
- /server perms
- /server channels
- /hash info
- /hash reload
- /hash compute (attachment)
- /hash check (attachment)
- /sus summary
- /sus user (user)
- /sus why (user)
- /sus list (filter, limit, cursor) — outputs plain “user_id - username_or_unknown” cache-only, no fetch
- /maint snapshot step
- /maint enforce step
- /maint flush
- /sus enforce (user, optional reason)
- /sus forgive (user)
- /sus reset (user)
- /config show (redact token; do not show OWNER_ID)
- /config get (key)
- /config set (key, value) with strict validation
- /config reset (key|all)
- /reload (owner/admin): reload hashes + reload config + flush caches + flush queue
- /restart (owner only): flush everything, then execv or graceful shutdown for external supervisor

CONFIG MODEL (guild-dependent)
- ./config.default.json plus per-guild override ./config.guild/<guild_id>.json
- Effective config = merged.
- Config keys (typed):
  - guild_id
  - unverified_role_id
  - action_log_channel_id
  - excluded_channel_ids
  - ignored_channel_ids
  - exemptions
  - exempt_role_ids
  - max_image_bytes
  - first_run_grace_days
  - inactive_days_threshold
  - inactivity_message_threshold (default 3)
  - snapshot_members_per_run
  - enforcement_scan_max_users_per_run
  - queue_max_jobs
  - queue_compact_threshold_bytes
  - worker_count
  - worker_job_timeout_seconds
  - queue_flush_interval_seconds
  - queue_state_flush_interval_seconds
  - hashes_files (list[str]; default ["./hashes.txt"])
  - extra_hashes (list[str]; sha256 hex strings)
  - enable_discord_cdn_url_scan (bool)
  - allowed_discord_cdn_domains (list[str])
  - enable_discord_message_link_scan (bool)
